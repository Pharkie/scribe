/**
 * @file config.h.example
 * @brief Configuration settings template for Scribe ESP32-C3 Thermal Printer
 * @author Adam Knowles
 * @date 2025
 * @copyright Copyright (c) 2025 Adam Knowles. All rights reserved.
 * @license Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International
 *
 * This file is part of the Scribe ESP32-C3 Thermal Printer project.
 *
 * This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0
 * International License. To view a copy of this license, visit
 * http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to
 * Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
 *
 * Commercial use is prohibited without explicit written permission from the author.
 * For commercial licensing inquiries, please contact Adam Knowles.
 *
 * Based on the original Project Scribe by UrbanCircles.

 */

#ifndef CONFIG_H
#define CONFIG_H

#include <ArduinoLog.h>
#include <esp_log.h>

// ============================================================================
// ESP32-C3 GPIO CONFIGURATION AND VALIDATION
// ============================================================================

// ESP32-C3 GPIO pin characteristics and availability
enum GPIOType
{
    GPIO_TYPE_SAFE = 0,
    GPIO_TYPE_STRAPPING = 1,
    GPIO_TYPE_UART = 2,
    GPIO_TYPE_LED_ONBOARD = 3
};

struct GPIOInfo
{
    int pin;
    GPIOType type;
    const char *description;
    bool canUseForButtons;
    bool canUseForLEDs;
    bool canUseForOutput;
};

// ESP32-C3 GPIO configuration (compile-time, not user-configurable)
// Based on ESP32-C3 datasheet and hardware constraints
static const GPIOInfo ESP32C3_GPIO_MAP[] = {
    {0, GPIO_TYPE_STRAPPING, "Strapping pin at boot, avoid input at boot", false, true, true},
    {1, GPIO_TYPE_UART, "TX for UART0 (USB-Serial), avoid for input", false, true, true},
    {2, GPIO_TYPE_SAFE, "Safe, general I/O", true, true, true},
    {3, GPIO_TYPE_UART, "RX for UART0 (USB-Serial), avoid for input", false, true, true},
    {4, GPIO_TYPE_SAFE, "Safe for buttons, LED, digital I/O", true, true, true},
    {5, GPIO_TYPE_SAFE, "Safe for buttons, LED, digital I/O", true, true, true},
    {6, GPIO_TYPE_SAFE, "Safe for buttons, LED, digital I/O", true, true, true},
    {7, GPIO_TYPE_SAFE, "Safe for buttons, LED, digital I/O", true, true, true},
    {8, GPIO_TYPE_LED_ONBOARD, "Onboard LED; can still be used, but affects LED", true, true, true},
    {9, GPIO_TYPE_SAFE, "Safe for buttons or outputs", true, true, true},
    {10, GPIO_TYPE_SAFE, "Safe for buttons or outputs", true, true, true},
    {20, GPIO_TYPE_SAFE, "UART1 TX - Safe for digital output (LED strip, etc.)", false, true, true},
    {21, GPIO_TYPE_SAFE, "UART1 RX - Safe for digital output (LED strip, etc.)", false, true, true}};

static const int ESP32C3_GPIO_COUNT = sizeof(ESP32C3_GPIO_MAP) / sizeof(ESP32C3_GPIO_MAP[0]);

// Helper functions for GPIO validation
static bool isValidGPIO(int pin)
{
    for (int i = 0; i < ESP32C3_GPIO_COUNT; i++)
    {
        if (ESP32C3_GPIO_MAP[i].pin == pin)
        {
            return true;
        }
    }
    return false;
}

static bool canUseGPIOForButtons(int pin)
{
    for (int i = 0; i < ESP32C3_GPIO_COUNT; i++)
    {
        if (ESP32C3_GPIO_MAP[i].pin == pin)
        {
            return ESP32C3_GPIO_MAP[i].canUseForButtons;
        }
    }
    return false;
}

static bool canUseGPIOForLEDs(int pin)
{
    for (int i = 0; i < ESP32C3_GPIO_COUNT; i++)
    {
        if (ESP32C3_GPIO_MAP[i].pin == pin)
        {
            return ESP32C3_GPIO_MAP[i].canUseForLEDs;
        }
    }
    return false;
}

static const char *getGPIODescription(int pin)
{
    for (int i = 0; i < ESP32C3_GPIO_COUNT; i++)
    {
        if (ESP32C3_GPIO_MAP[i].pin == pin)
        {
            return ESP32C3_GPIO_MAP[i].description;
        }
    }
    return "Unknown GPIO";
}

// Display current GPIO usage summary (call after boot validation)
// Implementation in config_utils.cpp

// ============================================================================
// RUNTIME DEFAULTS - Can be overridden by config.json
// ============================================================================
// WARNING: These are INITIAL DEFAULTS ONLY used to populate config.json on first setup
// In production, ALL these values will be OVERRIDDEN by config.json
// Users can modify these via the settings web interface

// Default WiFi settings
static const char *defaultWifiSSID = "YOUR_WIFI_SSID";
static const char *defaultWifiPassword = "YOUR_WIFI_PASSWORD";

// Default device identity
static const char *defaultDeviceOwner = "YOUR_DEVICE_NAME";
static const char *defaultTimezone = "Europe/London";

// Default MQTT broker settings
static const char *defaultMqttServer = "YOUR_MQTT_SERVER.hivemq.cloud";
static const int defaultMqttPort = 8883; // TLS port
static const char *defaultMqttUsername = "YOUR_MQTT_USERNAME";
static const char *defaultMqttPassword = "YOUR_MQTT_PASSWORD";

// Unbidden Ink (ChatGPT) API configuration
static const bool defaultEnableUnbiddenInk = false; // Enable/disable Unbidden Ink feature
static const char *defaultChatgptApiToken = "YOUR_OPENAI_API_KEY"; // Default ChatGPT API token
static const int defaultUnbiddenInkStartHour = 10;                                                 // Working hours start (24-hour format)
static const int defaultUnbiddenInkEndHour = 16;                                                   // Working hours end (24-hour format)
static const int defaultUnbiddenInkFrequencyMinutes = 60;                                          // Send 1 message in every X minute window

// Default button configuration (GPIO, actions, MQTT topics, LED effects)
struct ButtonConfig
{
    int gpio;
    const char *shortAction; // Direct content action type (JOKE, RIDDLE, etc.) - NOT HTTP endpoints
    const char *shortMqttTopic;
    const char *shortLedEffect;
    const char *longAction; // Direct content action type (JOKE, RIDDLE, etc.) - NOT HTTP endpoints
    const char *longMqttTopic;
    const char *longLedEffect;
};

// IMPORTANT: Hardware buttons call internal functions directly, NOT HTTP endpoints
// Actions are content types (JOKE, RIDDLE, QUOTE, etc.) that map to generateXXXContent() functions
// HTTP endpoints (/api/joke, etc.) are for web interface and MQTT only
//
// Note: GPIO are fixed in config.h, actions can be changed in config.json
// Empty MQTT topic means use local printing (no network calls)
//
// ESP32-C3 GPIO Notes:
// - Available GPIOs: 0-21 (some have restrictions)
// - GPIO 0,2,3,9: Strapping pins - can cause boot issues (GPIO 9 used for buttons anyway)
// - GPIO 1: UART0 TX (Serial) - can cause programming issues
// - GPIO 18,19: Used for USB, not available for general use
// - GPIO 5,6,7,4: Chosen for button inputs (avoiding strapping and problematic pins)
static const ButtonConfig defaultButtons[] = {
    {5, "JOKE", "", "chase_single", "PRINT_TEST", "", "pulse"}, // Button 1: Joke → Test Print
    {6, "RIDDLE", "", "chase_single", "", "", "pulse"},         // Button 2: Riddle → (no long action)
    {7, "QUOTE", "", "chase_single", "", "", "pulse"},          // Button 3: Quote → (no long action)
    {4, "QUIZ", "", "chase_single", "", "", "pulse"}            // Button 4: Quiz → (no long action) - GPIO 4 (safe pin)
};

// LEDs: Optional FastLED support
// Enabled via build flags (-DENABLE_LEDS=1 in platformio.ini)

#if ENABLE_LEDS
#include "led_config.h"
#endif

// ============================================================================
// BACKEND CONSTANTS - Fixed at compile time, not user-configurable
// ============================================================================

// Unbidden Ink frequency validation limits
constexpr int minUnbiddenInkFrequencyMinutes = 15; // Minimum frequency: 15 minutes
constexpr int maxUnbiddenInkFrequencyMinutes = 480;

// Hardware button settings
static const int numHardwareButtons = sizeof(defaultButtons) / sizeof(defaultButtons[0]); // Automatically calculated
static const unsigned long buttonDebounceMs = 50;                                         // Debounce time in milliseconds
static const unsigned long buttonLongPressMs = 2000;                                      // Long press threshold in milliseconds
static const bool buttonActiveLow = true;                                                 // true = button pulls to ground, false = button pulls to VCC

// Button rate limiting (separate from debouncing) - made more aggressive for ESP32-C3 stability
static const unsigned long buttonMinInterval = 5000;      // 5 seconds minimum between button presses (increased from 3s)
static const unsigned long buttonMaxPerMinute = 10;       // 10 button presses per minute max (reduced from 20)
static const unsigned long buttonRateLimitWindow = 60000; // 1 minute rate limit window

// Button task safety settings (ESP32-C3 specific)
static const int buttonTaskStackSize = 8192;   // 8KB stack for HTTP operations
static const int buttonTaskPriority = 1;       // Lower than main loop (priority 1)
static const int buttonQueueSize = 10;         // Max queued button actions
static const int buttonActionTimeoutMs = 3000; // 3s timeout for button-triggered HTTP calls (reduced from 5s)

// Network & Time Configuration
static const char *ntpServers[] = {
    "time.cloudflare.com", // Fastest - Cloudflare's global CDN
    "time.google.com",     // Very fast - Google's infrastructure
    "0.pool.ntp.org",      // Traditional reliable pool
    "1.pool.ntp.org"       // Backup pool server
};
static const int ntpServerCount = sizeof(ntpServers) / sizeof(ntpServers[0]);
static const int ntpSyncTimeoutSeconds = 30;    // Maximum wait time for initial NTP sync
static const int ntpSyncIntervalSeconds = 3600; // Re-sync interval (1 hour)

// Logging Configuration
// Logging levels: LOG_LEVEL_VERBOSE, LOG_LEVEL_NOTICE, LOG_LEVEL_WARN, LOG_LEVEL_ERROR
static const int logLevel = LOG_LEVEL_NOTICE;
static const esp_log_level_t espLogLevel = ESP_LOG_WARN;
static const bool enableSerialLogging = true;       // Serial console
static const bool enableFileLogging = false;        // LittleFS file (untested)
static const bool enableMQTTLogging = false;        // MQTT topic
static const bool enableBetterStackLogging = false; // BetterStack (slow but useful for debugging)
static const char *mqttLogTopic = "scribe/log";
static const char *logFileName = "/logs/scribe.log";
static const size_t maxLogFileSize = 100000; // 100KB

// External API endpoints
static const char *jokeAPI = "https://icanhazdadjoke.com/";
static const char *quoteAPI = "https://zenquotes.io/api/random";
static const char *triviaAPI = "https://the-trivia-api.com/api/questions?categories=general_knowledge&difficulty=medium&limit=1";
static const char *newsAPI = "https://feeds.bbci.co.uk/news/rss.xml";
static const char *chatgptApiEndpoint = "https://api.openai.com/v1/chat/completions"; // ChatGPT API URL (NEVER exposed to frontend)

// BetterStack configuration
static const char *betterStackToken = "YOUR_BETTERSTACK_TOKEN";
static const char *betterStackEndpoint = "YOUR_BETTERSTACK_ENDPOINT";

// Application Settings
static const int maxCharacters = 1000;      // Max characters per message (single source of truth)
static const int maxPromptCharacters = 500; // Max characters for Unbidden Ink prompts
static const int totalRiddles = 545;        // Total riddles in riddles.ndjson
static const char *apiUserAgent = "Scribe Thermal Printer (https://github.com/Pharkie/scribe)";

// Hardware Configuration
static const int TX_PIN = 21;           // TX pin to printer RX (green wire)
static const int heatingDots = 10;      // Heating dots (7-15, lower = less power)
static const int heatingTime = 150;     // Heating time (80-200ms)
static const int heatingInterval = 250; // Heating interval (200-250ms)

// System Performance Settings
static const unsigned long memCheckInterval = 60000;     // 60 seconds (memory check frequency)
static const unsigned long reconnectInterval = 5000;     // 5 seconds (WiFi reconnection interval)
static const unsigned long wifiConnectTimeoutMs = 15000; // 15 seconds timeout for WiFi connection
static const char *fallbackAPSSID = "Scribe-setup";
static const char *fallbackAPPassword = "scribe123";
static const int statusLEDPin = 8;    // ESP32-C3 has built-in LED on GPIO8
static const int webServerPort = 80;  // HTTP port for web server
const int watchdogTimeoutSeconds = 8; // Watchdog timeout in seconds

// Printer Discovery Heartbeat
static const unsigned long printerDiscoveryHeartbeatInterval = 60000; // 1 minute heartbeat interval

// Input Validation Limits
static const unsigned long minRequestInterval = 100;  // 100ms minimum between requests
static const unsigned long maxRequestsPerMinute = 60; // 60 requests per minute
static const unsigned long rateLimitWindowMs = 60000; // 1 minute rate limit window
static const int maxControlCharPercent = 10;          // Max control characters as percentage of message length
static const int maxJsonPayloadSize = 8192;           // 8KB max JSON payload size
static const int maxMqttTopicLength = 128;            // Max MQTT topic length
static const int maxParameterLength = 1000;           // Default max parameter length
static const int maxRemoteParameterLength = 100;      // Max length for remote parameter
static const int maxUriDisplayLength = 200;           // Max URI length for display (truncated after this)
static const int jsonDocumentSize = 1024;             // Standard JSON document buffer size
static const int largeJsonDocumentSize = 4096;        // Large JSON document buffer size (increased for config.json with API tokens)
static const int maxValidationErrors = 10;            // Max validation errors to store
static const int maxOtherPrinters = 10;               // Max other printers to track
static const int stringBufferSize = 64;               // Standard string buffer size
static const int topicBufferSize = 64;                // MQTT topic buffer size
static const int maxWifiPasswordLength = 64;          // Max WiFi password length
static const int maxTimezoneLength = 64;              // Max timezone string length
static const int minJokeLength = 10;                  // Minimum joke length to be considered valid

// Memo Configuration
static const int MEMO_COUNT = 4;        // Number of configurable memos
static const int MEMO_MAX_LENGTH = 500; // Maximum length per memo

#endif
